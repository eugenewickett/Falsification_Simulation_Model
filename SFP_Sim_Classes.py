"""
Created on Tue Nov 19 21:50:21 2019
@author: Eugene Wickett

Stores classes for use with 'Falsification Simulator.py'
"""
import numpy as np
import random

class DrugPacket:
    _numDP = 0 # Counter for our DPs
    
    def __init__(self, size=0, nodeIDList=[0]):
        DrugPacket._numDP += 1
        self.id = DrugPacket._numDP #Integer
        self.size = size #Integer
        self.nodeIDList = nodeIDList #List
        
class Node:
    def __init__(self, nodeNum=0, reorderPoint=0, reorderAmount=0, preferredSupplierVec=[0], preferredSupplierLTsVec=[0], preferredSupplierRsVec=[0], endNodeTF = False, falseProb = 0, demandSched=[]):
        self.id = nodeNum
        self.r = reorderPoint
        self.R = reorderAmount
        self.PreferenceList = preferredSupplierVec # A list of node numbers, in order of preference
        self.PreferenceLTsList = preferredSupplierLTsVec # A list of lead time means
        self.PreferenceRsList = preferredSupplierRsVec
        self.FalsifierProbability = falseProb
        self.InventoryLevel = [] # List of levels corresponding to each DPID
        self.InventoryDPID = [] # List of DP IDs
        self.InventoryPeriodsRemaining = [] # List of time periods remaining before corresponding inventory arrives; "0" means inventory is available for further distrubtion
        self.demandResults = [0,0] #List of demand results [Satisfied,Stockout] in number of units
        self.stockoutDays = 0 # Number of days stocked out
        self.EndNode = endNodeTF # Is this an end node?
        self.demandSched = demandSched # List of demands for each day; generated by demandScheduleGenerator(); only if EndNode = True
        self.DaysStockedOut = 0 # Tracker of how many simulation days the node has been stocked out
        self.AmountProcured = 0
        self.AmountProcuredDueToStockouts = 0
    
    def ProcessIncomingOrder(self): # Update incoming order time periods remaining by 1
        if np.sum(self.InventoryPeriodsRemaining) > 0: # We have an order in transit
            # Iterate through the list and drop each days remaining by one
            for invPile in range(len(self.InventoryPeriodsRemaining)):
                if self.InventoryPeriodsRemaining[invPile] > 0:
                    self.InventoryPeriodsRemaining[invPile] = self.InventoryPeriodsRemaining[invPile] - 1
    
    def ProcessScheduleDemand(self, simDay=0, DPList=[], RootList=[], rootConsumptionVec=[]): # Process demand for an end node with a demand schedule
        todayDemand = int(self.demandSched[simDay]) # Demand for today
        todayInventoryAvailable = 0
        for invPile in range(len(self.InventoryDPID)): # Iterate through our inventory piles and count how much is presently available
            if self.InventoryPeriodsRemaining[invPile] == 0:
                todayInventoryAvailable = todayInventoryAvailable + self.InventoryLevel[invPile]
        # Take the minimum of what's available or the demand; balance demand becomes stockout
        inventoryToTake = min(todayDemand,todayInventoryAvailable)
        stockoutDemand = todayDemand - inventoryToTake
        self.demandResults[1] += stockoutDemand # Increment dissatisfied customers
        currInvPile = 0
        while inventoryToTake > 0:
            if (self.InventoryPeriodsRemaining[currInvPile]==0) and (self.InventoryLevel[currInvPile]>0): # Inventory is available
                pileAmountToTake = min(inventoryToTake,self.InventoryLevel[currInvPile]) # Can only take inventory if it's there
                self.InventoryLevel[currInvPile] -= pileAmountToTake # Increment down the inventory pile
                inventoryToTake -= pileAmountToTake # Increment amount left to take
                self.demandResults[0] += pileAmountToTake # Increment satisfied customers
                currDPID = self.InventoryDPID[currInvPile] # Grab the DPID for obtaining statistics
                for indDP in DPList:
                    if indDP.id == currDPID: # Found the matching DPID
                        rootSupplier = indDP.nodeIDList[0]
                        rootSupplierInd = RootList.index(rootSupplier)
                        rootConsumptionVec[rootSupplierInd] += pileAmountToTake # Add pile amount to root nodes stat
                    
            currInvPile += 1 # Go to the next inventory pile
        ### END WHILE LOOP FOR INVENTORY
        return DPList, RootList, rootConsumptionVec
        
    def MakeOrder(self, rootList, intermediateList, DPList, LeadTimeVariance=0): # Check if current inventory levels are leq the reorder point, and make orders according to the preferred supplier list
        if np.sum(self.InventoryLevel) <= self.r: # We place an order
            # Iterate through the prefered suppliers list until we hit a root node
            Rremaining = self.R # Initialize the desired reorder amount
            suppInd = 0 # Supplier number is distinct from where the supplier's LT is in the list
            # If we're an end node, first decide if we're going to "procure" an SFP batch                
            if self.EndNode == True and (self.FalsifierProbability > random.uniform(0,1)): # Procure from the falsifier node directly, skipping the importers
                # Order the amount we normally would from our top preference; LT similarly
                logNormSig = np.sqrt(np.log(((LeadTimeVariance)/(self.PreferenceLTsList[0]**2)) + 1)) # For deriving log-normal LT variable
                logNormMu = np.log(self.PreferenceLTsList[0])-(logNormSig**2)/2
                currLT = int(np.round(np.random.lognormal(mean=logNormMu,sigma=logNormSig))) # LT from this supplier
                newDP = DrugPacket(size=Rremaining,nodeIDList=[1,self.id])
                self.InventoryLevel.append(newDP.size)
                self.InventoryDPID.append(newDP.id)
                self.InventoryPeriodsRemaining.append(currLT)                  
                DPList.append(newDP)
                self.AmountProcured += Rremaining
            else:
                for currSupplier in self.PreferenceList:
                    logNormSig = np.sqrt(np.log(((LeadTimeVariance)/(self.PreferenceLTsList[suppInd]**2)) + 1)) # For deriving log-normal LT variable
                    logNormMu = np.log(self.PreferenceLTsList[suppInd])-(logNormSig**2)/2
                    currLT = int(np.round(np.random.lognormal(mean=logNormMu,sigma=logNormSig))) # LT from this supplier
                    suppInd += 1
                    # Check if it is a root node
                    isRoot = False
                    for root in rootList:
                        if root==currSupplier: # We have a root
                            isRoot = True
                    # Place order if supplier is a root and we're an intermediate node
                    if isRoot == True and self.EndNode==False:
                        # If this node has a positive falsifier procurement probability,
                        # generate a random uniform and set the current supplier to 
                        # the falsifier node (node 1) if the uniform is below the threshold
                        if self.FalsifierProbability > random.uniform(0,1):
                            currSupplier = 1
                        
                        newDP = DrugPacket(size=Rremaining, nodeIDList=[currSupplier,self.id])
                        self.InventoryLevel.append(newDP.size)
                        self.InventoryDPID.append(newDP.id)
                        self.InventoryPeriodsRemaining.append(currLT)                  
                        DPList.append(newDP)
                        self.AmountProcured += Rremaining
                    # Place an order with the SFP node for the end node 
                    elif (isRoot == True) and (self.EndNode == True) and (np.sum(self.InventoryLevel) <= self.r):
                        # Only do so if our "patience" is reached
                        if 1 - (1 - self.FalsifierProbability)**3 > random.uniform(0,1):
                            logNormSig = np.sqrt(np.log(((LeadTimeVariance)/(self.PreferenceLTsList[0]**2)) + 1)) # For deriving log-normal LT variable
                            logNormMu = np.log(self.PreferenceLTsList[0])-(logNormSig**2)/2
                            currLT = int(np.round(np.random.lognormal(mean=logNormMu,sigma=logNormSig))) # LT from this supplier
                            newDP = DrugPacket(size=Rremaining,nodeIDList=[1,self.id])
                            self.InventoryLevel.append(newDP.size)
                            self.InventoryDPID.append(newDP.id)
                            self.InventoryPeriodsRemaining.append(currLT)                  
                            DPList.append(newDP)
                            self.AmountProcured += Rremaining
                            #Increment our tracking of "system stockout" orders
                            self.AmountProcuredDueToStockouts += Rremaining
                    else: # Need to order as much as possible from this intermediate node
                        for intermediate in intermediateList:
                            if intermediate.id == currSupplier: # We have located our intermediate node
                                supplierInventoryAvailable = 0
                                for invPile in range(len(intermediate.InventoryDPID)): # Iterate through our inventory piles and count how much is presently available
                                    if intermediate.InventoryPeriodsRemaining[invPile] == 0:
                                        supplierInventoryAvailable += intermediate.InventoryLevel[invPile] # Increment the available inventory from this intermediate node
                                # Take the minimum of what's available or the demand; balance demand becomes stockout
                                inventoryToTake = min(Rremaining,supplierInventoryAvailable)
                                Rremaining -= inventoryToTake
                                stockoutDemand = max(Rremaining,0) # Record stockout demand if taken inventory is less than the remaining reorder amount
                                intermediate.demandResults[1] += stockoutDemand # Increment dissatisfied customers
                                currInvPile = 0 # Start with intermediary's first inventory pile
                                while inventoryToTake > 0:
                                    if (intermediate.InventoryPeriodsRemaining[currInvPile]==0) and (intermediate.InventoryLevel[currInvPile]>0): # Inventory is available
                                        pileAmountToTake = min(inventoryToTake,intermediate.InventoryLevel[currInvPile]) # Can only take inventory if it's there
                                        tempDPID = intermediate.InventoryDPID[currInvPile]
                                        # Need to find the current DP
                                        for DPobj in DPList:
                                            if DPobj.id==tempDPID: #Found it
                                                oldDPList = DPobj.nodeIDList
                                        tempDPIDList = oldDPList + [self.id]
                                        newDP = DrugPacket(size=pileAmountToTake,nodeIDList=tempDPIDList)
                                        self.InventoryLevel.append(newDP.size) # Add pile to inventory list
                                        self.InventoryDPID.append(newDP.id)
                                        self.InventoryPeriodsRemaining.append(currLT)
                                        DPList.append(newDP)
                                        self.AmountProcured += pileAmountToTake
                                        intermediate.InventoryLevel[currInvPile] -= pileAmountToTake # Increment down the inventory pile
                                        inventoryToTake -= pileAmountToTake # Increment amount left to take
                                        intermediate.demandResults[0] += pileAmountToTake # Increment satisfied customers
                                    # END IF FOR AVAILABLE INVENTORY IN PILE
                                    currInvPile += 1 # Go to the next inventory pile
                                ### END WHILE LOOP FOR INVENTORY
                                                       
        return intermediateList, DPList # We may have made changes to these lists
                            
